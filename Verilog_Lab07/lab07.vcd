$date
	Sun Jul 12 22:15:26 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module flopenr $end
$var wire 1 ! clk $end
$var wire 8 " d [7:0] $end
$var wire 1 # en $end
$var wire 1 $ reset $end
$var reg 8 % q [7:0] $end
$upscope $end
$scope module testbench $end
$var wire 32 & writedata [31:0] $end
$var wire 1 ' memwrite $end
$var wire 32 ( dataadr [31:0] $end
$var reg 1 ) clk $end
$var reg 1 * reset $end
$scope module dut $end
$var wire 1 ) clk $end
$var wire 1 * reset $end
$var wire 32 + writedata [31:0] $end
$var wire 32 , readdata [31:0] $end
$var wire 32 - pc [31:0] $end
$var wire 1 ' memwrite $end
$var wire 32 . instr [31:0] $end
$var wire 32 / dataadr [31:0] $end
$scope module dmem $end
$var wire 1 ) clk $end
$var wire 32 0 rd [31:0] $end
$var wire 1 ' we $end
$var wire 32 1 wd [31:0] $end
$var wire 32 2 a [31:0] $end
$upscope $end
$scope module imem $end
$var wire 6 3 a [5:0] $end
$var wire 32 4 rd [31:0] $end
$upscope $end
$scope module mips $end
$var wire 1 ) clk $end
$var wire 32 5 instr [31:0] $end
$var wire 32 6 readdata [31:0] $end
$var wire 1 * reset $end
$var wire 1 7 zero $end
$var wire 32 8 writedata [31:0] $end
$var wire 1 9 regwrite $end
$var wire 1 : regdst $end
$var wire 1 ; pcsrc $end
$var wire 32 < pc [31:0] $end
$var wire 1 ' memwrite $end
$var wire 1 = memtoreg $end
$var wire 1 > jump $end
$var wire 1 ? bne $end
$var wire 1 @ alusrc $end
$var wire 32 A aluout [31:0] $end
$var wire 3 B alucontrol [2:0] $end
$scope module c $end
$var wire 6 C funct [5:0] $end
$var wire 6 D op [5:0] $end
$var wire 1 ; pcsrc $end
$var wire 1 7 zero $end
$var wire 1 9 regwrite $end
$var wire 1 : regdst $end
$var wire 1 ' memwrite $end
$var wire 1 = memtoreg $end
$var wire 1 > jump $end
$var wire 1 E branch $end
$var wire 1 ? bne $end
$var wire 1 @ alusrc $end
$var wire 2 F aluop [1:0] $end
$var wire 3 G alucontrol [2:0] $end
$scope module ad $end
$var wire 6 H funct [5:0] $end
$var wire 2 I aluop [1:0] $end
$var reg 3 J alucontrol [2:0] $end
$upscope $end
$scope module md $end
$var wire 6 K op [5:0] $end
$var wire 1 9 regwrite $end
$var wire 1 : regdst $end
$var wire 1 ' memwrite $end
$var wire 1 = memtoreg $end
$var wire 1 > jump $end
$var wire 1 E branch $end
$var wire 1 ? bne $end
$var wire 1 @ alusrc $end
$var wire 2 L aluop [1:0] $end
$var reg 10 M controls [9:0] $end
$upscope $end
$upscope $end
$scope module dp $end
$var wire 3 N alucontrol [2:0] $end
$var wire 1 @ alusrc $end
$var wire 1 ? bne $end
$var wire 1 ) clk $end
$var wire 32 O instr [31:0] $end
$var wire 1 > jump $end
$var wire 1 = memtoreg $end
$var wire 1 ; pcsrc $end
$var wire 32 P readdata [31:0] $end
$var wire 1 : regdst $end
$var wire 1 9 regwrite $end
$var wire 1 * reset $end
$var wire 1 7 zero $end
$var wire 5 Q writereg [4:0] $end
$var wire 32 R writedata [31:0] $end
$var wire 32 S srcb [31:0] $end
$var wire 32 T srca [31:0] $end
$var wire 32 U signimmsh [31:0] $end
$var wire 32 V signimm [31:0] $end
$var wire 32 W result [31:0] $end
$var wire 32 X pcplus4 [31:0] $end
$var wire 32 Y pcnextbr [31:0] $end
$var wire 32 Z pcnext [31:0] $end
$var wire 32 [ pcbranch [31:0] $end
$var wire 32 \ pc [31:0] $end
$var wire 32 ] aluout [31:0] $end
$scope module alu $end
$var wire 3 ^ op [2:0] $end
$var wire 32 _ result [31:0] $end
$var wire 32 ` logicout [31:0] $end
$var wire 1 7 cero $end
$var wire 32 a b [31:0] $end
$var wire 32 b arithout [31:0] $end
$var wire 32 c a [31:0] $end
$scope module a_block $end
$var wire 3 d op [2:0] $end
$var wire 32 e b [31:0] $end
$var wire 32 f arithout [31:0] $end
$var wire 32 g addout [31:0] $end
$var wire 32 h a [31:0] $end
$scope module first_adder_substractor $end
$var wire 1 i s $end
$var wire 32 j y [31:0] $end
$var wire 32 k con [31:0] $end
$var wire 32 l b [31:0] $end
$var wire 32 m a [31:0] $end
$scope module first_adder $end
$var wire 1 i s $end
$var wire 32 n b [31:0] $end
$var wire 32 o a [31:0] $end
$var reg 32 p y [31:0] $end
$upscope $end
$scope module first_mux $end
$var wire 32 q b [31:0] $end
$var wire 1 i s $end
$var wire 32 r y [31:0] $end
$var wire 32 s a [31:0] $end
$upscope $end
$upscope $end
$scope module first_stl $end
$var wire 32 t a [31:0] $end
$var wire 1 u s $end
$var wire 32 v y [31:0] $end
$var reg 32 w extend [31:0] $end
$scope module first_mux $end
$var wire 32 x a [31:0] $end
$var wire 32 y b [31:0] $end
$var wire 1 u s $end
$var wire 32 z y [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module answer $end
$var wire 32 { b [31:0] $end
$var wire 1 | s $end
$var wire 32 } y [31:0] $end
$var wire 32 ~ a [31:0] $end
$upscope $end
$scope module l_block $end
$var wire 3 !" op [2:0] $end
$var wire 32 "" b [31:0] $end
$var wire 32 #" a [31:0] $end
$var reg 32 $" logicout [31:0] $end
$upscope $end
$scope module z_block $end
$var wire 32 %" a [31:0] $end
$var reg 1 7 y $end
$upscope $end
$upscope $end
$scope module immsh $end
$var wire 32 &" y [31:0] $end
$var wire 32 '" a [31:0] $end
$upscope $end
$scope module pcadd1 $end
$var wire 32 (" b [31:0] $end
$var wire 32 )" y [31:0] $end
$var wire 32 *" a [31:0] $end
$upscope $end
$scope module pcadd2 $end
$var wire 32 +" a [31:0] $end
$var wire 32 ," b [31:0] $end
$var wire 32 -" y [31:0] $end
$upscope $end
$scope module pcbrmux $end
$var wire 32 ." d0 [31:0] $end
$var wire 32 /" d1 [31:0] $end
$var wire 1 ; s $end
$var wire 32 0" y [31:0] $end
$upscope $end
$scope module pcmux $end
$var wire 32 1" d0 [31:0] $end
$var wire 32 2" d1 [31:0] $end
$var wire 1 > s $end
$var wire 32 3" y [31:0] $end
$upscope $end
$scope module pcreg $end
$var wire 1 ) clk $end
$var wire 32 4" d [31:0] $end
$var wire 1 * reset $end
$var reg 32 5" q [31:0] $end
$upscope $end
$scope module resmux $end
$var wire 32 6" d0 [31:0] $end
$var wire 32 7" d1 [31:0] $end
$var wire 1 = s $end
$var wire 32 8" y [31:0] $end
$upscope $end
$scope module rf $end
$var wire 1 ) clk $end
$var wire 5 9" ra1 [4:0] $end
$var wire 5 :" ra2 [4:0] $end
$var wire 32 ;" wd3 [31:0] $end
$var wire 1 9 we3 $end
$var wire 5 <" wa3 [4:0] $end
$var wire 32 =" rd2 [31:0] $end
$var wire 32 >" rd1 [31:0] $end
$upscope $end
$scope module se $end
$var wire 16 ?" a [15:0] $end
$var wire 32 @" y [31:0] $end
$upscope $end
$scope module srcbmux $end
$var wire 32 A" d0 [31:0] $end
$var wire 32 B" d1 [31:0] $end
$var wire 1 @ s $end
$var wire 32 C" y [31:0] $end
$upscope $end
$scope module wrmux $end
$var wire 5 D" d0 [4:0] $end
$var wire 5 E" d1 [4:0] $end
$var wire 1 : s $end
$var wire 5 F" y [4:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b1000 F"
b10000 E"
b1000 D"
b11111111111111111000000000000000 C"
b11111111111111111000000000000000 B"
bx A"
b11111111111111111000000000000000 @"
b1000000000000000 ?"
b0 >"
bx ="
b1000 <"
b11111111111111111000000000000000 ;"
b1000 :"
b0 9"
b11111111111111111000000000000000 8"
bx 7"
b11111111111111111000000000000000 6"
b0 5"
b100 4"
b100 3"
b1000100000000000000000 2"
b100 1"
b100 0"
b11111111111111100000000000000100 /"
b100 ."
b11111111111111100000000000000100 -"
b11111111111111100000000000000000 ,"
b100 +"
b0 *"
b100 )"
b100 ("
b11111111111111111000000000000000 '"
b11111111111111100000000000000000 &"
b11111111111111111000000000000000 %"
bx $"
b0 #"
b11111111111111111000000000000000 ""
b10 !"
bx ~
b11111111111111111000000000000000 }
1|
b11111111111111111000000000000000 {
b11111111111111111000000000000000 z
b1 y
b11111111111111111000000000000000 x
b1 w
b11111111111111111000000000000000 v
0u
b11111111111111111000000000000000 t
b11111111111111111000000000000000 s
b11111111111111111000000000000000 r
b111111111111111 q
b11111111111111111000000000000000 p
b0 o
b11111111111111111000000000000000 n
b0 m
b11111111111111111000000000000000 l
b11111111111111111000000000000000 k
b11111111111111111000000000000000 j
0i
b0 h
b11111111111111111000000000000000 g
b11111111111111111000000000000000 f
b11111111111111111000000000000000 e
b10 d
b0 c
b11111111111111111000000000000000 b
b11111111111111111000000000000000 a
bx `
b11111111111111111000000000000000 _
b10 ^
b11111111111111111000000000000000 ]
b0 \
b11111111111111100000000000000100 [
b100 Z
b100 Y
b100 X
b11111111111111111000000000000000 W
b11111111111111111000000000000000 V
b11111111111111100000000000000000 U
b0 T
b11111111111111111000000000000000 S
bx R
b1000 Q
bx P
b100000000010001000000000000000 O
b10 N
b1010000000 M
b0 L
b1000 K
b10 J
b0 I
b0 H
b10 G
b0 F
0E
b1000 D
b0 C
b10 B
b11111111111111111000000000000000 A
1@
0?
0>
0=
b0 <
0;
0:
19
bx 8
07
bx 6
b100000000010001000000000000000 5
b100000000010001000000000000000 4
b0 3
b11111111111111111000000000000000 2
bx 1
bx 0
b11111111111111111000000000000000 /
b100000000010001000000000000000 .
b0 -
bx ,
bx +
1*
1)
b11111111111111111000000000000000 (
0'
bx &
bx %
z$
z#
bz "
z!
$end
#5
